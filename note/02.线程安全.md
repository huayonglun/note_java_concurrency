# 2. 线程安全
---
##  一些概念
1. 定义:
	- 要求无论是多线程中的时序或交替操作，都要保证不破坏哪些不变约束
2. 编写线程安全的代码，本质上就是
	- 管理对状态的访问，而且通常都是共享的、可变的状态
3. 一个对象的状态：
	- 就是它的数据，存储在状态变量中，比如实例域或静态域
4. 共享
	- 一个变量可以被多个线程访问
5. 可变
	- 变量的值在其生命周期内可以改变
6. **无论何时，只要有多于一个线程访问给定的状态变量，而且其中的某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问**
7. 在没有正确同步的情况下，如果多个线程访问了同一个变量，你的程序就存在隐患。有三种方法修复它：
	- 不要跨线程共享变量
	- 使状态变量变为不可变的
	- 在任何访问状态变量的时候使用同步

## 2.1 什么是线程安全性
- 一个类是线程安全的，是指在被多个线程访问时，类可以持续进行正确的行为
- 线程安全的类封装了任何必要的同步，因此客户不需要自己提供
- **无状态对象**永远是线程安全的
	- 多数Servlet都可以实现为无状态的，这一事实极大地降低了确保Servlet线程安全的负担，只有当Servlet要为不同的请求记录一些信息时，才会将线程安全的需求提到日程上来

## 2.2 原子性
- 向无状态对象中加入一个状态元素会怎样？
	- 假设我们想要添加命中数，来计算处理请求的个数。
	- 常见方法是在Servlet中添加一个long类型的域，并在请求中递增它
- 然而这并非线程安全的
- 它很容易遗失更新(lost updates)
- 自增操作++count由于其紧凑的语法格式，看上去更像一个单独的操作，然而它不是**原子操作**，这意味着它不能作为一个单独的、不可分割的操作去执行。
- 自增操作是3个离散操作的简写形式：
	- 获得当前值，
	- +1，
	- 写回新值
- 这是一个**读-改-写(read-modify-write)**操作的实例，其中，结果的状态衍生自它先前的状态

### 2.2.1 竞争条件
- 当计算的正确性依赖于运行时中相关的时序或者多线程的交替时，会产生竞争条件
- 想得到正确的答案，要依赖于“幸运的时序”
- 最常见的一种竞争条件是“检查再运行(**check-then-act**)”

### 2.2.2 示例：惰性初始化中的竞争条件
- 检查再运行的常见用法是惰性初始化
- 惰性初始化的目的是延迟对象的初始化
- 直到程序真正使用它，同时确保它只初始化一次
- 像大多数并发错误一样，竞争条件并不总是导致失败：还需要某些特殊的分时

### 2.2.3 复合操作
- 为避免竞争条件，必须阻止其他线程访问我们正在修改的变量，让我们可以确保：当其他线程想要查看或修改一个状态时，必须在我们的线程开始之前或者完成之后，而不能在操作过程中
- 我们将“检查再运行”和“读-改-写”操作的全部执行过程看做是复合操作：为了保证线程安全，操作必须原子地进行。

### 2.2.4 计数器在Servlet中线程不安全问题的解决
- java.util.concurrent.atomic包中包括了**原子变量(atomic variable)**类，这些类用来实现数字和对象引用的原子状态转换
- 把long类型的计数器替换为AtomicLong类型的，可以确保所有访问计数器状态的操作都是原子的
- 计数器是线程安全的了，而计数器的状态就是Servlet的状态，所以Servlet再次成为线程安全的了

## 2.3 锁
- 为保证状态的一致性，要在单一的原子操作中更新相互关联的状态变量

### 2.3.1 内部锁
- Java提供了强制原子性的内置锁机制：synchronized块
- 一个synchronized块有两部分：
	- 锁对象的引用
	- 这个锁保护的代码块
- 每个Java对象都可以隐式地扮演一个用于同步的角色：这些内置的锁被称作**内部锁(intrinsic locks)**或**监视器锁(monitor locks)**
- 内部锁在Java中扮演了**互斥锁(mutual exclusion lock / mutex)**的角色，意味着至多只有一个线程可以拥有锁，当线程A尝试请求一个被线程B占有的锁时，线程A必须等待或阻塞，直到B释放它。如果B永远不释放锁，A将永远等下去

### 2.3.2 重进入(Reentrancy)
- 当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞
- 然而内部锁是可重进入的，因此线程在试图获得它自己占有的锁时，请求会成功
- 重进入意味着所有请求是基于“”每线程(per-thread)，而不是基于“没调用(per-invocation)”的
- 重进入的实现是通过为每个锁关联一个请求计数(acquisition)和一个占有它的线程：
	- 当计数为0时，认为锁是未被占用的
	- 线程请求一个未被占用的锁时，JVM将记录锁的占有者，并且将请求计数置为1
	- 如果同一线程再次请求这个锁，计数将递增
	- 每次占用线程退出同步块，计数器将递减。直到计数器达到0，锁被释放
- 如果内部锁不是可重入的，代码可能会死锁：
	- 子类重写父类synchronized类型的方法，并调用父类中的方法


## 2.4 用锁来保护状态
- 因为锁能使得线程能够串行地访问它所保护的代码路径，所以我们可以用锁来创建相关的协议，以保证线程对共享状态的独占访问
- 只要始终如一地遵循这些协议，就能确保状态的一致性
- 每个共享的可变变量都需要由唯一一个确定的锁保护，而维护者应该清楚这个锁
- 常见的锁规则：
	- 在对象内部封装所有的可变状态，通过对象的内部锁来同步任何访问可变状态的代码路径，保护它在并发访问中的安全
	- Vector和其他同步的容器类都是这个模式
- 并不是所有数据都需要锁的保护——只有那些被多个线程访问的可变数据
- 对于每一个涉及多个变量的约束，需要同一个锁保护其所有的变量
- 既然同步可以避免竞争条件，为什么不将每个方法都声明为synchronized类型？
	- 如此武断的使用同步，可能导致程序中使用的同步过多或过少
	- 如同Vector这样，仅仅同步它的每个方法，并不足以确保在Vector上执行的复合操作是原子的：<br/>
	<code>if (!vector.contains(element))</code><br/>
	　　<code>vector.add(element);</code>
	- 虽然contains和add是原子的，但在尝试“缺少即加入(put-if-absent)”操作的过程中仍然存在竞争条件。
	- 虽然同步方法确保了不可分割操作的原子性，但是把多个操作整合到一个复合操作时，还是需要额外的锁。
	- 同步每个方法还会导致活跃度或性能问题

## 2.5 活跃度与性能
- 通常简单性和性能之间是相互牵制。实现一个同步策略时，不要过早地为了性能而牺牲简单性（这是对安全性潜在的威胁）
- 当使用锁的时候，你应该清楚块中的代码的功能，以及它的执行过程是否会很耗时。无论是作运算密集型的操作，还是在执行一个可能存在潜在阻塞的操作，如果线程长时间地占有锁，就会引起活跃度与性能风险的问题
- 有些耗时的计算或操作，比如网络或控制台I/O，难以快速完成，执行这些操作期间不要占有锁


