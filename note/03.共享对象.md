# 3. 共享对象
---
　　同步有两个重要方面：原子操作或者划定临界区；内存可见性。我们不仅希望能够避免一个线程修改其他线程正在使用的对象的状态，而且希望确保当一个线程修改了对象的状态后，其他线程能够真正的看到改变。但是没用同步，这些可能都不会发生。你可以使用显式的同步，或者利用内置于类库中的同步机制，来保证对象的安全发布。

## 3.1 可见性
　　在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是判断错误。有一个简单的方法来避免这些复杂的问题：只要数据需要被跨线程共享，就进行**恰当的同步**

### 3.1.1 过期数据
- 没有恰当同步的程序，它能够引起意外的后果：过期数据
- 当读线程检查ready变量时，它可能看到一个过期的值
- 除非每一次访问变量都是同步的，否则很可能得到变量的过期值
- 更坏的情况是，过期既不会发生在全部变量上，也不会完全不出现：一个线程可能会得到一个变量最新的值，但是也可能得到另一个变量先前写入的过期值
- 过期数据的危害
	- 引起安全错误，导致打印错误数据，或者程序无法终止
	- 使对象引用中的数据更加复杂，比如链指针在链表中的实现
	- 引发严重且混乱的错误，比如意外的异常，脏的数据结构，错误的计算和无限的循环

### 3.1.2 非原子的64位操作
- 最低限的安全性(out-of-thin-air safety)
	- 一个线程在没有同步的情况下读取变量，可能得到过期值
	- 但至少可以看到某个线程在那里设定的一个真实数值，而不是一个凭空而来的值。
	- 这样的安全保证为最低限的安全性
- 最低限的安全性应用于所有的变量
	- 例外：没有声明为volatile的64位数值变量。
	- Java存储模型要求获取和存储操作都为原子的，但是对于非volatile的long和double变量，JVM允许将64位的读或写划分为两个32位的操作。
	- 如果读和写发生在不同的线程，这种情况读取一个非volatile类型long就可能会出现得到一个值的高32位和另一个值的低32位
	- 所以不安全，除非声明为volatile类型或加锁保护


### 3.1.3 锁和可见性
- 当访问一个共享的可变变量时，为什么要求所有线程由同一个锁进行同步，我们现在可以给出另一个理由：
	- 为了保证一个线程对数值进行的写入，其他线程也都可见
	- 另一方面，如果一个线程在没有恰当地使用锁的情况下读取了变量，那么这个变量很可能是一个过期的数据
- 锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步

### 3.1.4 Volatile变量
- Java中同步的弱形式：volatile变量
- 它确保对一个变量的更新以可预见的方式告知其他线程
- 当一个域声明为volatile类型后，编译器与运行时都会监视这个变量：它是共享的，而且对它的操作不会与其他的内存操作一起被重排序
- volatile变量不会缓存在寄存器或者缓存在对其他处理器隐藏的地方
- 所以，读一个volatile类型的变量时，总会返回由某一线程所写入的最新值
- volatile变量相对于sychronized而言，只是轻量级的同步机制
- volatile变量对可见性的影响所产生的价值远远高于变量本身
- 正确使用volatile变量的方式包括：
	- 用于确保它们所引用的对象状态的可见性
	- 用于标识重要的生命周期事件(比如初始化或关闭)的发生
- **加锁可以保证可见性与原子性；volatile变量只能保证可见性**
- 只有满足了下面所有的标准后，你才能使用volatile变量：
	- 写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值；
	- **变量不需要与其他的状态变量共同参与不变约束**
	- 而且访问变量时，没有其他的原因需要加锁

## 3.2 发布和逸出
　　发布一个对象：使它能够被当前范围之外的代码所使用<br/>
　　逸出：一个对象在尚未准备好时就将它发布

- 最常见的发布对象的方式是将对象的引用存储到公共静态域中。任何类和线程都能看见这个域

### 3.2.1 安全构建的实践
- 重要的逸出特例——this引用在构造时逸出
- 一个导致this引用在构造期间逸出的常见错误，是在构造函数中启动一个线程。当对象在构造函数中创建了一个线程时，无论是显式地（通过将它传给构造函数）还是隐式地（因为Thread或Runnable是所属对象的内部类），this引用几乎总是被新线程共享
- 如果想在构造函数中注册监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，这样避免了不正确的创建

## 3.3 线程封闭
　　访问共享的、可变的数据要求使用同步。一个可以避免同步的方式就是不共享数据。如果数据仅在单线程中被访问，就不需要任何同步。线程封闭(Thread confinement)技术是实现线程安全的最简单的方式之一

- Swing发展了线程封闭技术
- 另一种常见的使用线程限制的应用程序是应用池化的JDBC的Connection对象
	- JDBC的规范并没有要求Connection对象是线程安全的
	- 然而典型的服务器应用中，线程总是从池中获得一个Connection对象，并且用它处理一个单一的请求，最后把它归还
	- 每个线程都会同步地处理大多数请求（比如Servlet请求或EJB调用），而且在Connection对象在被归还前，池不会将它再分配给其他线程
	- 因此，这种连接管理模式隐式的将Connection对象限制在处于请求处理期间的线程中

### 3.3.1 Ad-hoc线程限制
- 是指维护线程限制性的任务全部落在实现上的这种情况
- 未经过设计而得到的线程封闭行为

### 3.3.2 栈限制
- 栈限制是线程封闭的一种特例
- 栈限制中，只能通过本地变量才可以触及对象
- 正如封装使不变约束更容易被保持，本地变量使对象更容易被限制在线程本地中
- 本地变量本身就被限制在执行线程中：它们存在于执行线程栈。其他线程无法访问这个栈。
- 栈限制比起Ad-hoc线程限制更易维护，更健壮

### 3.3.3 ThreadLocal
- 维护线程限制的更加规范的方式是使用ThreadLocal，它允许你将每个线程与持有数值的对象关联在一起。
- ThreadLocal提供了get与set访问器，为每个使用它的线程维护一份单独的拷贝
- 所以get总是返回由当前执行线程通过set设置的最新值
- 线程本地（ThreadLocal）变量通常用于防止在基于可变的单体（Singleton）或全局变量的设计中，出现（不正确的）共享。比如说：一个单线程化的应用程序可能会维护一个全局的数据库连接，这个Connection在启动时就已经被初始化了。这样就可以避免为每个方法都传递一个Connection。
- 这项技术还用于下面的情况：
	- 一个频繁执行的操作既需要像buffer这样的临时对象，同时还需要避免每次都重分配（reallocate）该临时对象

## 3.4 不可变性
　　满足同步的需要，另一种方法就是使用不可变对象。

- 创建后状态不能被修改的对象叫做不可变对象
- 不可变对象永远是线程安全的
- 不可变对象不会被恶意的或者漏洞百出的代码所破坏，所以它们是安全的，可以放心的共享和发布，不需要创建防御性拷贝
- **所有域都是final类型对象仍然可以是可变的**，因为final域可以获得一个可变对象的引用
- 只有满足如下状态，一个对象才是不可变的：
	- 它的状态不能在创建后再被修改
	- 所有域都是final类型
	- 它被正确创建（创建期间没有发生this引用的逸出）
- 对象是不可变的 与 对象的引用是不可变的 之间并不等同
	- 程序存储在不可变对象中的状态仍然可以通过替换一个带有新状态的不可变对象的实例得到更新

### 3.4.1 Final域
- 它对不可变性对象的创建提供了支持
- final域是不能修改的

### 3.4.2使用volatile发布不可变对象
　　不可变的容器持有与不变约束相关的多个状态变量，并利用volatile引用确保及时的可见性

## 3.5 安全发布
　　目前为止，我们都关注确保对象不会被发布。比如，让对象限制在线程中或者另一个对象的内部。当然，有时我们又的确希望跨线程共享对象，这时我们必须安全地共享它。

### 3.5.1 不正确发布：当好对象变坏时
- 没有正确发布的对象会导致两种错误：
	- 首先，发布线程以外的任何线程都可以看到Holder域的过期值，因而看到的是一个null引用或者旧值，即使Holder已经被赋予新值
	- 其次，更坏的情况是，线程看到的Holder引用是最新的，然而Holder状态却是过期的

### 3.5.2 不可变对象与初始化安全性
- 由于不可变对象的安全性，Java存储模型为共享不可变对象提供了特殊的初始化安全性的保证。
- 不可变对象可以在没有额外同步的情况下，安全地用于任意线程；甚至发布它们时亦不需要同步

### 3.5.3 安全发布的模式
- 如果一个对象不是不可变的，它就必须被安全地发布，通常发布线程与消费线程都必须同步化
- 为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过下列条件安全地发布：
	- 通过静态初始化器初始化对象的引用
	- 将它的引用存储到volatile域或AtomicReference
	- 将它的引用存储到正确创建的对象的final域中
	- 或者将它的引用存储到由锁正确保护的域中

### 3.5.4 高效不可变对象（Effectively immutable objects）
- 一个对象在技术上不是不可变的，但是它的状态不会在发布后被修改，这样的对象称作有效不可变对象
- 这种对象不必满足不可变性的约束条件；这些对象发布后程序只需简单地把他们当做不可变对象。
- 用高效不可变对象可以简化开发，并且由于减少了同步的使用，还会提高性能
- 任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象
- 比如，Date自身是可变的，但是如果你把它当做不可变对象来使用就可以忽略锁。否则，每当Date被跨线程共享时，都要用锁确保安全。假设你正在维护一个Map，它存储了每位用户的最近登录时间。
```public Map<String,Date> lastLogin =```
```Collections.synchronizedMap(new HashMap<String,Date>());```如果Date值在置入Map中后就不会改变，那么synchronizedMap中同步的实现,对于安全地发布Date值，是至关重要的。而访问这些Date值时就不需要额外的同步

### 3.5.5 可变对象
- 为了保证安全地共享可变对象，可变对象必须被安全发布，同时必须是线程安全的或者是被锁保护的
- 发布对象的必要条件依赖于对象的可变性
	- 不可变对象可以通过任意机制发布
	- 高效不可变对象必须要安全发布
	- 可变对象必须要安全发布，同时必须要线程安全或者被锁保护

### 3.5.6 安全的共享对象
- 在并发程序中，使用和共享对象的一些最有效的策略如下：
	- 线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改
	- 共享只读(shared read-only)：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它，共享只读对象不包括可变对象与高效不可变对象
	- 共享线程安全(shared thread-safe):一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意访问它
	- 被守护的(Guarder):一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已被特定的锁保护起来的已发布对象



















