# 1. 介绍
---
## 并发的历史
- 顺序编程模型
- 线程允许程序控制流的多重分支同时存在于一个进程中，共享进程内资源
- 线程有时候被成为轻量级进程，大多数现代操作系统时序调度的基本单元

## 线程的优点
- 降低开发和维护的开销，提高复杂应用的性能
- 把异步工作流转化为顺序流，使程序模拟人类工作和交互变得更加容易
- 把复杂、难以理解的代码转化为直接、简洁的代码，易读写及维护
- 在GUI应用中改进用户接口的响应性
- 在服务器应用中提高资源的利用率和吞吐量
- 简化JVM的实现，垃圾收集器通常运行于一个或多个持续工作的线程之间
- 大部分至关重要的Java应用都依赖于线程，某种程度上是因为它们的组织结构需要这样

## 线程的风险
### 安全危险
- 常见的并发危险
	- 竞争条件(race condition)

### 活跃度的危险
- 线程的使用引入了又一形式的活跃度失败(liveness failure)
- 活跃度意味着好的事情终究会发生
- 当一个活动进入某种它永远无法再继续执行的状态时，活跃度失败发生
- 活跃度失败包括：
	- 死锁(deadlock)
	- 饥饿(starvation)
	- 活锁(livelock)

### 性能危险
- 性能：希望好的事情尽快发生
- 性能问题包括：
	- 服务时间
	- 响应性
	- 吞吐量
	- 资源消费
	- 可伸缩性
- 上下文切换(Context switches)
	- 当调度程序临时挂起当前运行的线程时，另一个线程开始运行
	- 这在多线程应用中频繁，带来巨大的系统开销：
		- 保存和恢复线程执行的上下文
		- 离开执行现场
		- CPU时间花费在对线程的调度而不是运行上
		- 当线程共享数据时，必须同步，这会限制编译器的优化
		- 能够清空或锁定内存和高速缓存
		- 并在共享内存的总线上创建同步通信，这些因素引入性能开销

## 线程无处不在

### 定时器
- Timer用来调度一些稍后运行的任务，也可以是只运行一次或者周期性运行的任务
- TimerTasks运行在由Timer管理的线程中，并不是由应用程序来管理
- 如果一个TimeTask访问了其他应用程序线程正在访问的数据，那么不仅TimerTask需要线程安全的手段，并且**其他那些同时访问这个数据的类也需要相应措施**
- 通常实现方法是确保TimerTask访问的对象本身是线程安全的
- 因此应该将线程安全性封装到共享对象的内部

### Servlets and JavaServer Pages(JSPs)
- Servlets框架设计目的是处理Web应用的部署，分发来自远程HTTP客户的请求这些基础层业务
- 一个请求到达Server并被分发后，可能通过一个过滤器链到达相应的Servlet或者JSP
- 每一个Servlet代表应用逻辑的一个组件
- 在访问量较大的网站中，许多客户可能同时对相同Servlet的服务提出请求
- Servlets的规范规定了一个Servlet必须为多个用户同时调用它作好准备
- 换句话说，Servlets应该是线程安全的
- 当一个Servlet访问的对象是在Servlets间共享或者请求间共享时，必须对这些对象的访问控制进行适当协调，因为来自不同线程的多个请求可能同时访问它们
- Servlet、JSP和Servlet Filter以及哪些存储在ServletContext和HttpSession容器中的对象，明显必须是线程安全的

### 远程方法调用(Remote Method Invocation)
- RMI使你能够调用在另外一个JVM上运行的对象的方法
- 使用RMI调用一个远程方法时，这个方法的参数被打包成一个比特流，并且穿越网络到达远程JVM，在那里会解包并传递给远程方法
- 一个远程对象必须去守卫两种线程安全风险：
	- 对那些可能会与其他对象共享的状态进行适当调节，应正确地对远程对象本身进行调控
	- RMI对象应该对同时发生的多个调用有所准备，并且必须提供它们自己的线程安全

### Swing 和 AWT
- GUI应用程序具有固有的异步特性
- 当用户进行了一个UI活动，事件线程会调用事件处理器来执行用户请求的操作。
- 如果处理器需要访问应用程序状态，这里很可能有其他程序正在访问，那么事件的处理器，与其他访问状态的代码必须以线程安全的方式工作